---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
def merge_sort (array):

    if len(array) == 1:
        return array

    elif len(array) > 1:
        midpoint = len(array) // 2
        s1 = merge_sort(array[:midpoint])
        s2 = merge_sort(array[midpoint:])
        
        for i in s1:
            index = 0
            for j in s2:
                if j >= i:
                    s2.insert(index, i)
                    break
                if index + 1 == len(s2):
                    s2.append(i)
                    break
                index += 1
        return s2
```

```{python}
arr = [2,3,1,66,0,9]
```

```{python}
merge_sort(arr2)
```

```{python}
arr = [6,3,4,5,6,6,6]
merge_sort(arr)
```

Compare with the merge sort implementation below and identify everything wrong with it.

```{python}
# def merge_sort_bad (array):

#     if len(array) == 1:
#         return array

#     elif len(array) > 1:
#         midpoint = len(array) // 2
#         s_1 = merge_sort(array[:midpoint])
#         s_2 = merge_sort(array[midpoint:])
#         while len(s2) > 0:
#             i = s2.pop()
#             index_j = 0
#             for j in s1:
#                 index_j += 1
#                 if j > i:
#                     s1.insert(index_j, s2)
#                 break

#     return s1
```

`index_j` incrementation should below line 17 as it should only be increment if current value is > or =.  

`if j > i:` does account for when `j == i` which is also a case where `i` should be inserted.  

`break` statement should be within `if` statement of line 16  

there is no case for when you are the end of the `s1` array because all values are less than the `i`, leading to missing values.  

`[?]` why would you want to implement a while loop instead of a for loop?  


`[?]` what key methods do you need from a data structure to enable easy implementation of merge sort?  


#### Neater Implementation of Merge Sort

```{python}
def merge_sort2(array):

    if len(array) == 1:
        return array

    else:

        mid = len(array) // 2
        A = merge_sort2(array[:mid])
        B = merge_sort2(array[mid:])

        for a in A:

            i = 0
            for b in B:

                if a >= b:
                    B.insert(i,a)
                    break

                if i+1 == len(B):
                    B.append(a)
                    break
                
                i += 1

        return B
```

```{python}
arr2 = [6,6,6,6,6,6,9,11]
merge_sort2(arr2)
```

#### Faster Implementation

```{python}
def merge_sort2(array):

    if len(array) == 1:
        return array

    else:

        mid = len(array) // 2
        A = merge_sort2(array[:mid])
        B = merge_sort2(array[mid:])

        for a in A:

            i = 0
            for b in B:

                if a >= b:
                    B.insert(i,a)
                    break

                if i+1 == len(B):
                    B.append(a)
                    break
                
                i += 1

        return B
```
