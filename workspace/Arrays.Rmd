---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

### Arrays

In python Arrays are called lists. Arrays are contiguous memory data structure, which means each item is placed next to eachother in memory. When accessing the array, an index is used which refers to the target memory as: `index 0 address` + `size of item type` + `index`.  
This allows the arrays methods to jump to the target items without having to consider all the items in the array. This leads to the access of items in arrays to be a constant time $O(1)$ operation.  

```{python}
new_list = [1,2,3]
new_list[0]
```

Arrays must enforce the contigous memory allocation, infact you can only add new items to an array using the `.append` method [[nkmk-lists]](https://note.nkmk.me/en/python-list-append-extend-insert).

```{python}
new_list.append(4)
new_list
```

The `size of item type` indicates that arrays requires the items to have predetermined size. In fact languages such as C, Swift and Java only allow the arrays to be of a single type. This is referred to as hemongenous arrays. Python allows for heterogeneous arrays which means mixed data types can be stored in an array. But since, different data types can have different allocated sizes, and none of it predetermined, Python pointers of those items instead. So a Python array access method will do something like this: `index 0 address` + `size of pointer type` + `index`.

```{python}
new_list.append("imma-a-string")
new_list
```

So when ask the array to point to an index, the method will form the memory address and get the item in that address. But since that those bytes of memory are not part of the array type, it fails to read them.

```{python}
new_list[5] ## index out of range
```

#### Operations on the Array

So far adding, intialising and retrieving items from an array has been shown. Let's try searching an array, which the demo will show is a far more expensive operation to perform, particularly in Python due to its pointers.

The following shows the use of the `in` operator to check if `new_list` contains 1. It calls a `contains` method which performs a linear search through the array to true if the item value exists. Even the acess and read operations are constant time, they still need to be performed as they there are items in the array, leading to a linear runtime $O(n)$.

```{python}
1 in new_list
```

__Inserting Items in an Array__  
True insert involves adding an item to a specified in an array, causing the rest of the items on the right to shift an index of + 1. This there for a linear runtime operation when considering adding a new value at index 0.


__Appending Items in an Array__  
This is a special case of insert, where the new item is added at end of an array, i.e. `array[len(array)] = "new_item"`. This is a constant time operation as jumping to the end of array is constant time and so it adding an item. There is no overhead of considering the rest of the items in an array.  
One caveat is that append's runtime complexity can be different for other languages because of its implementation.


When defining an empty list, Python allocates a 1 items array in memory. But inspite of that, when calling its length, it return 0. Indicating that Python is considering more than the memory allocation of the list to determine the length.

```{python}
numbers = []
len(numbers)
```

Lets append an item:

```{python}
numbers.append(2)
len(numbers)
```

Now the length of the array and the size in memory match. Now when appending another item, python must call a list resizing operation in order to increase the memory allocation of the list. There is a lot of ingenuity in its implementation.

```{python}
numbers.append(200)
```

```{python}

```
