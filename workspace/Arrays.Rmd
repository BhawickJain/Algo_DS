---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

### Arrays

In python Arrays are called lists. Arrays are contiguous memory data structure, which means each item is placed next to eachother in memory. When accessing the array, an index is used which refers to the target memory as: `index 0 address` + `size of item type` + `index`.  
This allows the arrays methods to jump to the target items without having to consider all the items in the array. This leads to the access of items in arrays to be a constant time $O(1)$ operation.  

```{python}
new_list = [1,2,3]
new_list[0]
```

Arrays must enforce the contigous memory allocation, infact you can only add new items to an array using the `.append` method [[nkmk-lists]](https://note.nkmk.me/en/python-list-append-extend-insert).

```{python}
new_list.append(4)
new_list
```

The `size of item type` indicates that arrays requires the items to have predetermined size. In fact languages such as C, Swift and Java only allow the arrays to be of a single type. This is referred to as hemongenous arrays. Python allows for heterogeneous arrays which means mixed data types can be stored in an array. But since, different data types can have different allocated sizes, and none of it predetermined, Python pointers of those items instead. So a Python array access method will do something like this: `index 0 address` + `size of pointer type` + `index`.

```{python}
new_list.append("imma-a-string")
new_list
```

So when ask the array to point to an index, the method will form the memory address and get the item in that address. But since that those bytes of memory are not part of the array type, it fails to read them.

```{python}
new_list[5] ## index out of range
```

#### Operations on the Array

So far adding, intialising and retrieving items from an array has been shown. Let's try searching an array, which the demo will show is a far more expensive operation to perform, particularly in Python due to its pointers.

The following shows the use of the `in` operator to check if `new_list` contains 1. It calls a `contains` method which performs a linear search through the array to true if the item value exists. Even the acess and read operations are constant time, they still need to be performed as they there are items in the array, leading to a linear runtime $O(n)$.

```{python}
1 in new_list
```
