---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

### Binary Search

Binary Search takes a list sorted in ascending order and a target value. Taking the Upper and Lower index bounds (e.g. len(list)-1 and 0) and finds floored midpoint index. It checks that midpoint position value from the list with the target value. If the midpoint value is too large, the Upper bound is set as the midpoint - 1 and if too small, the Lower bound is set as midpoint + 1. 

The search stops until the list(midpoint) == target or the lower bound is no longer Lower <= Upper

```{python}
def bin_search(list, target):
    lower = 0
    upper = len(list)-1
    
    while lower <= upper:
        midpoint = (lower + upper)//2
        print(lower, upper, midpoint, target)
        
        if list[midpoint] == target:
            return midpoint
        elif list[midpoint] > target:
            upper = midpoint - 1
        else:
            lower = midpoint + 1
            
    return None
```

```{python}
listA = [x for x in range(5,10)]
```

```{python}
pos = bin_search(listA, 2)
```

```{python}
pos
```

I wonder if there is a recursive version of this.

```{python}
def eval_mid(lower, upper, list, target):

    midpoint = (lower + upper)//2

    print(lower, upper, midpoint, list[midpoint], target)
    
    if lower > upper:
        return None

    elif list[midpoint] == target:
        return midpoint

    elif list[midpoint] > target:
        upper = midpoint - 1
        return eval_mid(lower, upper, list, target)

    elif list[midpoint] < target:
        lower = midpoint + 1
        return eval_mid(lower, upper, list, target)



def rec_bin_search(list, target):
    
    lower = 0
    upper = len(list)-1
    print("L", "U", "M", "C", "T") ## C for current value at midpoint
    pos = eval_mid(lower, upper, list, target)
    return pos
    
```

```{python}
pos = rec_bin_search(listA, 5)
```

One of the big assumptions is that the list must be sorted in ascending order.   
`[ ]` Is there way to check that without running a full sort algorithm? 


The version of recursion resizes the original list and calls the function again. What is lost are the upper and lower bounds relative to the original list, but otherwise it appears neater.

```{python}
def rec2_bin_search(list, target, debug=False):

    midpoint = (0 + len(list)-1)//2
    
    if debug == True:
        print(list)

    if 0 > midpoint:
        if debug == True:
            print('None')
        return None    
    
    elif list[midpoint] == target:
        if debug == True:
            print(f'[{list[midpoint]}]') 
        return midpoint

    elif list[midpoint] > target:
        return rec2_bin_search(list[:midpoint], target, debug)

    elif list[midpoint] < target:
        return rec2_bin_search(list[midpoint+1:], target, debug)
```

```{python}
pos = rec2_bin_search(listA, 100, debug=True)
```

`[ ]` Is a function call expensive?  
`[ ]` Is there a cost to making binary search resursive?  

syntax sugar: `midpoint+1:` instead of `midpoint+1:len(list)-1`  
syntax sugar: `:midpoint` instead of `:midpoint`

```{python}

```
