---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

### Binary Search

Binary Search takes a list sorted in ascending order and a target value. Taking the Upper and Lower index bounds (e.g. len(list)-1 and 0) and finds floored midpoint index. It checks that midpoint position value from the list with the target value. If the midpoint value is too large, the Upper bound is set as the midpoint - 1 and if too small, the Lower bound is set as midpoint + 1. 

The search stops until the list(midpoint) == target or the lower bound is no longer Lower <= Upper

```{python}
def bin_search(list, target):
    lower = 0
    upper = len(list)-1
    
    while lower <= upper:
        midpoint = (lower + upper)//2
        print(lower, upper, midpoint, target)
        
        if list[midpoint] == target:
            return midpoint
        elif list[midpoint] > target:
            upper = midpoint - 1
        else:
            lower = midpoint + 1
            
    return None
```

```{python}
listA = [x for x in range(5,10)]
```

```{python}
pos = bin_search(listA, 2)
```

```{python}
pos
```

I wonder if there is a recursive version of this.

```{python}
def eval_mid(lower, upper, list, target):

    midpoint = (lower + upper)//2

    print(lower, upper, midpoint, list[midpoint], target)
    
    if lower > upper:
        return None

    elif list[midpoint] == target:
        return midpoint

    elif list[midpoint] > target:
        upper = midpoint - 1
        return eval_mid(lower, upper, list, target)

    elif list[midpoint] < target:
        lower = midpoint + 1
        return eval_mid(lower, upper, list, target)



def rec_bin_search(list, target):
    
    lower = 0
    upper = len(list)-1
    print("F", "L", "M", "C", "M")
    pos = eval_mid(lower, upper, list, target)
    return pos
    
```

```{python}
pos = rec_bin_search(listA, 5)
```

```{python}
pos
```

tightened version

```{python}
def eval_mid(lower, upper, list, target):

    midpoint = (lower + upper)//2

    print(lower, upper, midpoint, list[midpoint], target)

    if list[midpoint] == target:
        return midpoint

    elif list[midpoint] > target:
        return eval_mid(lower, midpoint - 1, list, target)

    elif list[midpoint] < target:
        return eval_mid(midpoint + 1, upper, list, target)

    elif lower > upper:
        return None

def rec_bin_search(list, target):
    
    lower = 0
    upper = len(list)-1
    pos = eval_mid(lower, upper, list, target)
    return pos
    
```

```{python}
pos = rec_bin_search(listA, 5)
```

`[ ]` One of the big assumptions is that the list must be sorted in ascending order. Is there way to check that without running a full sort algorithm?  
`[ ]` Is a function call expensive?  
`[ ]` Is there a cost to making binary search resursive?  
