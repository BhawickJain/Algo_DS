---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

## Linked List

#### Why build your own data structures?
Sometimes the data structures a programming language provides are too costly from a time and space complexity perspective for your usage profile. For example, Arrays are great to reading and retrieving values ($O(1)$) but are slower when inserting and deleting items ($O(n)$). If you have a case where you do a lot inserting and deleting, a linked list is slightly better.

`[ ]` Find more reasons why building your own data structures can be better

#### What is a linked list?

It is a linear data structure where each item is a node which carries a value and a pointer to the next node. The first node of the list is known as the head and the last node as the tail. Most implementations only know the location of the head of the list, some also keep track of the tail. Node are known as self-referential objects as each node points to another node and the definition of the node refers to itself.  
There are two kinds of linked lists: singly linked list, where each node has one pointer to the next node, and a doubly linked list, where each node has two pointers the extra one referring to the previous node. With a doubly linked list, you can move up and down the linked list, you can't do that with a singly linked list.

```{python}
class Node:
    """
    An object for storing a single node of a linked list.
    Models two attributes - data and the link to the next node in the list
    """
    data = None
    next_node = None
    
    def __init__(self, data):
        self.data = data
        
        
    def __repr__(self):
#         return "<Node data: %s %s>" % self.data % self.next_node
        return f"<Node data: {self.data}>"
```

```{python}
class LinkedList:
    """
    Singly-linked list
    """
    
    def __init__(self):
        self.head = None
        
    def is_empty(self):
        """
        return True is self.head == None is true
        """
        return self.head == None
    
    def append(self, data):
        """
        Creates a new node with Data at the tail node
        This new node then becomes the Tail Node
        """
        
        if self.head == None:
            self.head = Node(data)
        else:
            current = self.head
            while current.next_node:
                current = current.next_node

            current.next_node = Node(data)
            
    def prepend(self, data, debug=False):
        """
        Creates a new head node with the target data
        ans sets the previous head to .next_node to current head
        """
        previous_head = self.head
        if debug==True: print(f"previous_head: \t {previous_head}")
        self.head = Node(data)
        if debug==True: print(f"new self.head: \t {self.head}")
        self.head.next_node = previous_head
        if debug==True: print(f"next_node: \t {self.head.next_node}")
                        
    def __repr__(self):
        return (f"<Linked List> \t{self.head} \ncount: {self.size()}")
    
    # convenience method
    def size(self):
        """ 
        Returns the number of nodes in the list
        Takes O(n) time
        """
        current = self.head
        count = 0
        
        while current: #!= None
            count = count + 1
            current = current.next_node
            
        return count
    
    # convenience method
    def to_array(self):
        """
        takes a LinkedList Object and constructs an 
        array of data attributes for each node
        """
        current = self.head
        array = []
        
        while current:
            array.append(current.data)
            current = current.next_node
            
        return array
```

`[ ]` How do you substitute two variables in a string using `%`? fix `line 22`  
`[ ]` Why does the above code work, inspite not explicit reasoning around pointers?

__Convenience Method__  

A convenience method is a method are affordances a data structure can provide that do not add functionality to the data structure per se, but instead give methods for the usual thing you would do. This ensures you don't have to recreate a method and assures you can focus on the code that specifically bring the functionality you're concerned with. It allows the author of the data structure to write the most efficient and convenient version.

In the `LinkedList` Class, I have provided `size` and `to_array` methods which one can implement themselves but why make 'em do it is common?

```{python}
N1 = Node(10)
# <__main__.Node at 0x7fe89449b760>    # Without __repr__
# <Node data: 10>                      # With __repr__
```

```{python}
N2 = Node(20)
N1.next_node = N2
```

`[?]` At `line 2`, does the assignment to `next_node` involve passing the pointer to the object or the object itself?  
`[?]` When does the assignment operator give the object itself and when is the pointer around?


Without the `__repr__` dunder you get not-so-human friendly python jargon. Use `__repr__` to return something sensible and helpful.

```{python}
L1 = LinkedList()
L1.append(10)
L1.append(20)
```

You can add loads of items with a range to the linked list! Lets give the .size() method a try.

```{python}
for x in range(1,10):
    L1.append(x)

# L1.size()
# 11
```

Notice how when having brackets at end of `size` tells python it is method not a variable in the object. Much like you access `L1.head` to get data but `L1.head()` gives you uncallable type error.

```{python}
# L1.head()

# ---------------------------------------------------------------------------
# TypeError                                 Traceback (most recent call last)
# <ipython-input-109-ccb65b2c2cd9> in <module>
# ----> 1 L1.head()

# TypeError: 'Node' object is not callable
```

Lets try use the `.to_array` method.

```{python}
# L1.to_array()
# [10, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

The `.prepend` function in a linked list needs to parse all the way to the tail node. Of course I could create a feature that allows the tail node to be recorded and take advantage of that.  

`[ ] ` Create a `.tail` attribute which records the tail node.  
`[?] ` What impact does having the `.tail` attribute have to the rest of the functions?  
`[?] ` How does the Big O change for the function with / without the `.tail` attribute?

```{python}
L1.append(100)
# [10, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 100]
```

The `.prepend` function simply swaps the `head` attritbute with a new node and ensure the old head is recorded to the new head's `.next_node` attribute. No shifting of indexes is required.

```{python}
L1.prepend(100) # debug=True

# previous_head: 	 <Node data: 10>
# new self.head: 	 <Node data: 100>
# next_node: 	 <Node data: 10>

# [100, 10, 20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 100]
```

`[ ]` Create an `.insert` method for the `LinkedList` class that takes an index and data to be added.  
`[v]` Modify the `.insert` method so that data is added _after_ a node with a given value.  
`[v]` Modify the `.insert` method give an option to add _before_ a node with a given value.  
`[ ]` Reason the Big O values for the `.append`, `.prepend` and `.insert` functions.  

`[ ]` Create a `.delete` method to delete at `head`.  <br>
`[ ]` Create a `.delete` method to delete at `tail`.  <br>
`[ ]` Create a `.delete` method to delete at an index(th) node.  <br> 

`[?]` How does Complexity of the `.delete` method compare with the array in python?  
`[?]` Given that Python Arrys uses Pointers anyway, how large of a space-time complexity difference would you expectin languages like C, Swift or Java which don't do that?  
