---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

## Linked List

#### Why build your own data structures?
Sometimes the data structures a programming language provides are too costly from a time and space complexity perspective for your usage profile. For example, Arrays are great to reading and retrieving values ($O(1)$) but are slower when inserting and deleting items ($O(n)$). If you have a case where you do a lot inserting and deleting, a linked list is slightly better.

`[ ]` Find more reasons why building your own data structures can be better

#### What is a linked list?

It is a linear data structure where each item is a node which carries a value and a pointer to the next node. The first node of the list is known as the head and the last node as the tail. Most implementations only know the location of the head of the list, some also keep track of the tail. Node are known as self-referential objects as each node points to another node and the definition of the node refers to itself.  
There are two kinds of linked lists: singly linked list, where each node has one pointer to the next node, and a doubly linked list, where each node has two pointers the extra one referring to the previous node. With a doubly linked list, you can move up and down the linked list, you can't do that with a singly linked list.

```{python}
class Node:
    """
    An object for storing a single node of a linked list.
    Models two attributes - data and the link to the next node in the list
    """
    data = None
    next_node = None
    
    def __init__(self, data):
        self.data = data
        
        
    def __repr__(self):
#         return "<Node data: %s %s>" % self.data % self.next_node
        return f"<Node data: {self.data}>"
```

```{python}
class LinkedList:
    """
    Singly-linked list
    """
    
    def __init__(self):
        self.head = None
        
    def is_empty(self):
        return self.head == None
    
    def add(self, data):
        if self.head == None:
            self.head = Node(data)
        else:
            current = self.head
            while current.next_node:
                current = current.next_node
            
            current.next_node = Node(data)
                        
    def __repr__(self):
    return (f"<Linked List> {self.head}")
    
    # convenience method
    def size(self):
        """ 
        Returns the number of nodes in teh list
        Takes O(n) time
        """
        current = self.head
        count = 0
        
        while current: #!= None
            count = count + 1
            current = current.next_node
            
        return count
    
    # convenience method
    def to_array(self):
        current = self.head
        array = []
        
        while current:
            array.append(current.data)
            current = current.next_node
            
        return array
```

`[ ]` How do you substitute two variables in a string using `%`? fix `line 14`  
`[ ]` Why does the above code work, inspite not explicit reasoning around pointers?  

```{python}
N1 = Node(10)
# <__main__.Node at 0x7fe89449b760>    # Without __repr__
# <Node data: 10>                      # With __repr__
```

```{python}
N2 = Node(20)
N1.next_node = N2
```

`[?]` At `line 2`, does the assignment to `next_node` involve passing the pointer to the object or the object itself?  
`[?]` When does the assignment operator give the object itself and when is the pointer around?


Without the `__repr__` dunder you get not-so-human friendly python jargon. Use `__repr__` to return something sensible and helpful.

```{python}
L1 = LinkedList()
L1.add(10)
L1.add(20)

for x in range(1,10):
    L1.add(x)

L1.size()
```

```{python}
L1.to_array()
```
